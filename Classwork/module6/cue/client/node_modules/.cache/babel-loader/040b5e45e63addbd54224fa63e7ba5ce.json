{"ast":null,"code":"import axios from 'axios';\nconst spotifyUserAPI = axios.create(); // declare localStorage keys\n\nexport const LOCALSTORAGE_KEYS = {\n  accessToken: 'spotify_access_token',\n  refreshToken: 'spotify_refresh_token',\n  expireTime: 'spotify_token_expire_time',\n  timestamp: 'spotify_token_timestamp'\n}; // retrieve localStorage values\n\nexport const LOCALSTORAGE_VALUES = {\n  accessToken: localStorage.getItem(LOCALSTORAGE_KEYS.accessToken),\n  refreshToken: localStorage.getItem(LOCALSTORAGE_KEYS.refreshToken),\n  expireTime: localStorage.getItem(LOCALSTORAGE_KEYS.expireTime),\n  timestamp: localStorage.getItem(LOCALSTORAGE_KEYS.timestamp)\n};\n/**\n * Clear out all localStorage items we've set and reload the page\n */\n\nexport const spotifyLogout = () => {\n  localStorage.clear();\n};\n/**\n * Checks if the amount of time that has elapsed between the timestamp in localStorage\n * and now is greater than the expiration time of 3600 seconds (1 hour).\n */\n\nconst hasTokenExpired = () => {\n  const {\n    accessToken,\n    timestamp,\n    expireTime\n  } = LOCALSTORAGE_VALUES;\n\n  if (!accessToken || !timestamp) {\n    return false;\n  }\n\n  const millisecondsElapsed = Date.now() - Number(timestamp);\n  return millisecondsElapsed / 1000 > Number(expireTime);\n};\n/**\n * Use the refresh token in localStorage to hit the /refresh_token endpoint\n * in our Node app, then update values in localStorage with data from response.\n */\n\n\nconst refreshToken = async () => {\n  try {\n    // Logout if there's no refresh token stored or we've managed to get into a reload infinite loop\n    if (!LOCALSTORAGE_VALUES.refreshToken || LOCALSTORAGE_VALUES.refreshToken === 'undefined' || Date.now() - Number(LOCALSTORAGE_VALUES.timestamp) / 1000 < 1000) {\n      console.error('No refresh token available');\n      spotifyLogout();\n    } // Use `/refresh_token` endpoint from our Node app\n\n\n    const {\n      data\n    } = await axios.get(`/refresh_token?refresh_token=${LOCALSTORAGE_VALUES.refreshToken}`); // Update localStorage values\n\n    localStorage.setItem(LOCALSTORAGE_KEYS.accessToken, data.access_token);\n    localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now()); // Reload the page for localStorage updates to be reflected\n\n    window.location.reload();\n  } catch (e) {\n    console.error(e);\n  }\n};\n\nconst getAccessToken = () => {\n  const queryString = window.location.search;\n  const urlParams = new URLSearchParams(queryString);\n  const queryParams = {\n    [LOCALSTORAGE_KEYS.accessToken]: urlParams.get('access_token'),\n    [LOCALSTORAGE_KEYS.refreshToken]: urlParams.get('refresh_token'),\n    [LOCALSTORAGE_KEYS.expireTime]: urlParams.get('expires_in')\n  };\n  const hasError = urlParams.get('error'); // If there's an error OR the token in localStorage has expired, refresh the token\n\n  if (hasError || hasTokenExpired() || LOCALSTORAGE_VALUES.accessToken === 'undefined') {\n    refreshToken();\n  } // // If there is a valid access token in localStorage, use that\n\n\n  if (LOCALSTORAGE_VALUES.accessToken && LOCALSTORAGE_VALUES.accessToken !== 'undefined') {\n    return LOCALSTORAGE_VALUES.accessToken;\n  } // If there is a token in the URL query params, user is logging in for the first time\n\n\n  if (queryParams[LOCALSTORAGE_KEYS.accessToken]) {\n    // Store the query params in localStorage\n    for (const property in queryParams) {\n      window.localStorage.setItem(property, queryParams[property]);\n    } // Set timestamp to keys\n\n\n    window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now()); // Return access token from query params\n\n    return queryParams[LOCALSTORAGE_KEYS.accessToken];\n  }\n\n  return false;\n};\n\nexport const accessToken = getAccessToken();\nspotifyUserAPI.interceptors.request.use(config => {\n  config.headers.Authorization = `Bearer ${accessToken}`;\n  config.baseURL = 'https://api.spotify.com/v1';\n  return config;\n});\nexport const spotifyUser = spotifyUserAPI;\nexport const getCurrentUserProfile = () => spotifyUserAPI.get('/me');\nexport const getCurrentUserTop = queryLength => spotifyUserAPI.get(`/me/top/${queryLength}`); // // ** either by selection => album/ep etc name or song name\n// export const getSearchBy = (artist, selection) => spotifyUserAPI.get(`/search?q=artist:${artist}&track=${selection}`);\n// // ****\n// export const getArtistTracks = (artistID) => spotifyUserAPI.get(`/artist/`);\n// // ****\n// export const getArtistAlbum = (artistID) => spotifyUserAPI.get(`/artists/${artistID}/albums`);\n// // use this w map to map through albumIDs and return tracks\n// export const getAlbumTracks = (albumID) => spotifyUserAPI.get(`/artists/${albumID}/tracks`);\n// export const getUserTopTracks = () => spotifyUserAPI.get(`/me/top/tracks?limit=3&time_range=short_term`);","map":{"version":3,"sources":["/Users/quinntoncarter/Documents/VSchool/Classwork/module6/cue/client/src/components/spotify.js"],"names":["axios","spotifyUserAPI","create","LOCALSTORAGE_KEYS","accessToken","refreshToken","expireTime","timestamp","LOCALSTORAGE_VALUES","localStorage","getItem","spotifyLogout","clear","hasTokenExpired","millisecondsElapsed","Date","now","Number","console","error","data","get","setItem","access_token","window","location","reload","e","getAccessToken","queryString","search","urlParams","URLSearchParams","queryParams","hasError","property","interceptors","request","use","config","headers","Authorization","baseURL","spotifyUser","getCurrentUserProfile","getCurrentUserTop","queryLength"],"mappings":"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","sourcesContent":["import axios from 'axios';\nconst spotifyUserAPI = axios.create();\n\n// declare localStorage keys\nexport const LOCALSTORAGE_KEYS = {\n    accessToken: 'spotify_access_token',\n    refreshToken: 'spotify_refresh_token',\n    expireTime: 'spotify_token_expire_time',\n    timestamp: 'spotify_token_timestamp',\n}\n\n// retrieve localStorage values\nexport const LOCALSTORAGE_VALUES = {\n    accessToken: localStorage.getItem(LOCALSTORAGE_KEYS.accessToken),\n    refreshToken: localStorage.getItem(LOCALSTORAGE_KEYS.refreshToken),\n    expireTime: localStorage.getItem(LOCALSTORAGE_KEYS.expireTime),\n    timestamp: localStorage.getItem(LOCALSTORAGE_KEYS.timestamp),\n};\n\n/**\n * Clear out all localStorage items we've set and reload the page\n */\nexport const spotifyLogout = () => {\n  localStorage.clear()\n};\n\n/**\n * Checks if the amount of time that has elapsed between the timestamp in localStorage\n * and now is greater than the expiration time of 3600 seconds (1 hour).\n */\nconst hasTokenExpired = () => {\n    const { accessToken, timestamp, expireTime } = LOCALSTORAGE_VALUES;\n    if (!accessToken || !timestamp) {\n        return false;\n    }\n    const millisecondsElapsed = Date.now() - Number(timestamp);\n    return (millisecondsElapsed / 1000) > Number(expireTime);\n};\n\n/**\n * Use the refresh token in localStorage to hit the /refresh_token endpoint\n * in our Node app, then update values in localStorage with data from response.\n */\nconst refreshToken = async () => {\n    try {\n      // Logout if there's no refresh token stored or we've managed to get into a reload infinite loop\n        if (!LOCALSTORAGE_VALUES.refreshToken ||\n        LOCALSTORAGE_VALUES.refreshToken === 'undefined' ||\n        (Date.now() - Number(LOCALSTORAGE_VALUES.timestamp) / 1000) < 1000\n        ) {\n        console.error('No refresh token available');\n        spotifyLogout();\n        }\n\n      // Use `/refresh_token` endpoint from our Node app\n        const { data } = await axios.get(`/refresh_token?refresh_token=${LOCALSTORAGE_VALUES.refreshToken}`);\n\n      // Update localStorage values\n        localStorage.setItem(LOCALSTORAGE_KEYS.accessToken, data.access_token);\n        localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\n\n      // Reload the page for localStorage updates to be reflected\n        window.location.reload();\n\n    } catch(e) {\n        console.error(e);\n    }\n};\n\nconst getAccessToken = () => {\n    const queryString = window.location.search;\n    const urlParams = new URLSearchParams(queryString);\n    const queryParams = {\n        [LOCALSTORAGE_KEYS.accessToken]: urlParams.get('access_token'),\n        [LOCALSTORAGE_KEYS.refreshToken]: urlParams.get('refresh_token'),\n        [LOCALSTORAGE_KEYS.expireTime]: urlParams.get('expires_in'),\n    };\n    const hasError = urlParams.get('error');\n\n    // If there's an error OR the token in localStorage has expired, refresh the token\n    if (hasError || hasTokenExpired() || LOCALSTORAGE_VALUES.accessToken === 'undefined') {\n        refreshToken();\n    }\n\n    // // If there is a valid access token in localStorage, use that\n    if (LOCALSTORAGE_VALUES.accessToken && LOCALSTORAGE_VALUES.accessToken !== 'undefined') {\n        return LOCALSTORAGE_VALUES.accessToken;\n    }\n\n    // If there is a token in the URL query params, user is logging in for the first time\n    if (queryParams[LOCALSTORAGE_KEYS.accessToken]) {\n      // Store the query params in localStorage\n        for (const property in queryParams) {\n        window.localStorage.setItem(property, queryParams[property]);\n        }\n      // Set timestamp to keys\n        window.localStorage.setItem(LOCALSTORAGE_KEYS.timestamp, Date.now());\n      // Return access token from query params\n        return queryParams[LOCALSTORAGE_KEYS.accessToken];\n    }\n\n    return false;\n}\n\nexport const accessToken = getAccessToken();\n\nspotifyUserAPI.interceptors.request.use(config => {\n    config.headers.Authorization = `Bearer ${accessToken}`\n    config.baseURL = 'https://api.spotify.com/v1'\n    return config\n});\nexport const spotifyUser = spotifyUserAPI\nexport const getCurrentUserProfile = () => spotifyUserAPI.get('/me');\nexport const getCurrentUserTop = (queryLength) => spotifyUserAPI.get(`/me/top/${queryLength}`);\n// // ** either by selection => album/ep etc name or song name\n// export const getSearchBy = (artist, selection) => spotifyUserAPI.get(`/search?q=artist:${artist}&track=${selection}`);\n// // ****\n// export const getArtistTracks = (artistID) => spotifyUserAPI.get(`/artist/`);\n// // ****\n// export const getArtistAlbum = (artistID) => spotifyUserAPI.get(`/artists/${artistID}/albums`);\n// // use this w map to map through albumIDs and return tracks\n// export const getAlbumTracks = (albumID) => spotifyUserAPI.get(`/artists/${albumID}/tracks`);\n// export const getUserTopTracks = () => spotifyUserAPI.get(`/me/top/tracks?limit=3&time_range=short_term`);"]},"metadata":{},"sourceType":"module"}